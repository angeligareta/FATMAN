<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fatman: Way Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fatman
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classWay.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classWay-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Way Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side, we store both ways. Doing that if we discover that the way we went was not the best one (comparing it to all the possible ways) we can simply go back and check another way. Each way has a position, diameter and area, to allow us to keep moving from it.  
 <a href="classWay.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43e2c66c0cdb5a6509551fa3f65e1770"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a43e2c66c0cdb5a6509551fa3f65e1770">get_diameter</a> () const</td></tr>
<tr class="separator:a43e2c66c0cdb5a6509551fa3f65e1770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6bd43a694231699729c4df69c0538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#ae8b6bd43a694231699729c4df69c0538">get_next_ways</a> ()</td></tr>
<tr class="separator:ae8b6bd43a694231699729c4df69c0538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5aa157413b5ab19621cbe84f6d02f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWay.html">Way</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#afd5aa157413b5ab19621cbe84f6d02f5">operator=</a> (const <a class="el" href="classWay.html">Way</a> &amp;way)</td></tr>
<tr class="separator:afd5aa157413b5ab19621cbe84f6d02f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5fd5102040f540de66e55c660efe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a1dc5fd5102040f540de66e55c660efe1">Way</a> (const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;actual_position, const double &amp;diameter, const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;area)</td></tr>
<tr class="separator:a1dc5fd5102040f540de66e55c660efe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2ae246e3c250ebefcb96ce02a69775"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a0e2ae246e3c250ebefcb96ce02a69775">Way</a> (const <a class="el" href="classWay.html">Way</a> &amp;way)</td></tr>
<tr class="separator:a0e2ae246e3c250ebefcb96ce02a69775"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a56251aabe4123e96a39117c4ec876b0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a56251aabe4123e96a39117c4ec876b0d">check_obstacle_in_line</a> (const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;actual_position, const double &amp;bottom, const double &amp;top)</td></tr>
<tr class="separator:a56251aabe4123e96a39117c4ec876b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f4a970c553090110822cdee9f21b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWay.html">Way</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a91f4a970c553090110822cdee9f21b72">create_way</a> (const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;actual_position, const double &amp;bottom, const double &amp;top) const</td></tr>
<tr class="separator:a91f4a970c553090110822cdee9f21b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ca50339dea2e210391259ce0c87f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a74ca50339dea2e210391259ce0c87f99">divide_ways</a> ()</td></tr>
<tr class="separator:a74ca50339dea2e210391259ce0c87f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6097f4b2873173c39bf9ef0ca01ab232"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a6097f4b2873173c39bf9ef0ca01ab232">divide_ways_with_obstacle</a> (const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;actual_position, const double &amp;bottom, const double &amp;top)</td></tr>
<tr class="separator:a6097f4b2873173c39bf9ef0ca01ab232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d8ccb71e27fef142dabc525705a79"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#ab09d8ccb71e27fef142dabc525705a79">get_correct_diameter</a> (const double &amp;diameter, const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;area) const</td></tr>
<tr class="separator:ab09d8ccb71e27fef142dabc525705a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2789fa1b2e365d8c896c66fb076d1de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#aa2789fa1b2e365d8c896c66fb076d1de">get_distance_between</a> (const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;position_1, const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;position_2) const</td></tr>
<tr class="separator:aa2789fa1b2e365d8c896c66fb076d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9fb28926e8db8613e7e58743e0b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a90c9fb28926e8db8613e7e58743e0b1a">get_last_obstacle</a> (const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;area) const</td></tr>
<tr class="separator:a90c9fb28926e8db8613e7e58743e0b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0ff6a97906581d1919a96d6a739abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#abb0ff6a97906581d1919a96d6a739abe">get_next_obstacle</a> (const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;area) const</td></tr>
<tr class="separator:abb0ff6a97906581d1919a96d6a739abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a78a964b350c8b64c1fdc64aebd9ba121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a78a964b350c8b64c1fdc64aebd9ba121">actual_position_</a></td></tr>
<tr class="separator:a78a964b350c8b64c1fdc64aebd9ba121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad255829300df475c7e95213b9f7da31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#ad255829300df475c7e95213b9f7da31f">area_</a></td></tr>
<tr class="separator:ad255829300df475c7e95213b9f7da31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304bad84a34c3b19368a2cdb37db2d3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a6304bad84a34c3b19368a2cdb37db2d3">checked_obstacles</a></td></tr>
<tr class="separator:a6304bad84a34c3b19368a2cdb37db2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b2f2c249bc1d99da8805ab03284469"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a39b2f2c249bc1d99da8805ab03284469">diameter_</a></td></tr>
<tr class="separator:a39b2f2c249bc1d99da8805ab03284469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3e83ee1ea2a22d2c44c613adc5cc6760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWay.html#a3e83ee1ea2a22d2c44c613adc5cc6760">operator&lt;</a> (const <a class="el" href="classWay.html">Way</a> &amp;way_1, const <a class="el" href="classWay.html">Way</a> &amp;way_2)</td></tr>
<tr class="separator:a3e83ee1ea2a22d2c44c613adc5cc6760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side, we store both ways. Doing that if we discover that the way we went was not the best one (comparing it to all the possible ways) we can simply go back and check another way. Each way has a position, diameter and area, to allow us to keep moving from it. </p>
<p>Represent a way in the test.</p>
<ul>
<li>*</li>
<li>Each time that we see an obstacle, instead of going to the bigger side, we store both ways.</li>
<li>Doing that if we discover that the way we went was not the best one</li>
<li>(comparing it to all the possible ways) we can simply go back and check another way.</li>
<li></li>
<li><p class="startli">Each way has a position, diameter and area, to allow us to keep moving from it. */ class <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> {</p>
<p class="startli">private: Position actual_position_; /**&lt; Actual position of the way (the obstacle where it is). */ double diameter_; /**&lt; Diameter of the fat person if we use this way. */ Area area_; /**&lt; Area that we are analyzing in that way. There will be a way for any different area. */ std::vector&lt;Position&gt; checked_obstacles; /**&lt; Obstacles that we have seen (used in </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classWay.html#a56251aabe4123e96a39117c4ec876b0d">check_obstacle_in_line()</a>).*/</dd></dl>
<p>public: /**</p><ul>
<li>Constructor of a way with the neccesary parameters to continue looking for the best path.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is).</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diameter</td><td>Diameter of the fat person if we use this way.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area that we are analyzing in that way. There will be a way for any different area. */ <a class="el" href="classWay.html#a1dc5fd5102040f540de66e55c660efe1">Way(const Position&amp; actual_position, const double&amp; diameter, const Area&amp; area)</a>: actual_position_(actual_position), diameter_(diameter), area_(area), checked_obstacles(std::vector&lt;Position&gt;()) {}</td></tr>
  </table>
  </dd>
</dl>
/**</li>
<li>Copy constructor where we use the '=' overload. Used by set.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way</td><td><a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> we want to copy. */ <a class="el" href="classWay.html#a0e2ae246e3c250ebefcb96ce02a69775">Way(const Way&amp; way)</a> { *this = way; }</td></tr>
  </table>
  </dd>
</dl>
/**</li>
<li>Overload of the operator '='.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way</td><td><a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> we want to copy. */ <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a>&amp; operator= (const <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a>&amp; way) { actual_position_ = way.actual_position_; diameter_ = way.diameter_; area_ = way.area_;</td></tr>
  </table>
  </dd>
</dl>
return *this; }</li>
</ul>
</li>
</ul>
<p>/**</p><ul>
<li>Used to compare two ways.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way_1</td><td>First way.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way_2</td><td>Second way. */ friend bool operator&lt; (const <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a>&amp; way_1, const <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a>&amp; way_2) { return way_1.diameter_ &lt; way_2.diameter_; }</td></tr>
  </table>
  </dd>
</dl>
/**</li>
<li>Method used to know in which ways we can divide our problems.</li>
<li>- First we look for the next obstacle in our way (attending to the area).</li>
<li>- If there are no more obstacles we insert this one in the finished_way_set.</li>
<li><p class="startli">- If there are more obstacles we diviide our way in <a class="el" href="classWay.html#a74ca50339dea2e210391259ce0c87f99">divide_ways()</a>. */ void get_next_ways () { actual_position_ = get_next_obstacle(area_);</p>
<p class="startli">if (actual_position_ == Position(-1,-1)) { finished_way_set.insert(*this); } else { <a class="el" href="classWay.html#a74ca50339dea2e210391259ce0c87f99">divide_ways()</a>; } }</p>
</li>
</ul>
<p>/**</p><ul>
<li>Diameter getter.</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>diameter_ Diameter of the fat person if we use this way. */ double get_diameter () const { return diameter_; }</dd></dl>
private:</li>
</ul>
<p>/**</p><ul>
<li>Returns the distance between two position of our way using the euclidian algorithm.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position_1</td><td>First position.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position_2</td><td>Second position.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>Euclidian distance. */ double <a class="el" href="classWay.html#aa2789fa1b2e365d8c896c66fb076d1de">get_distance_between(const Position&amp; position_1, const Position&amp; position_2) const</a> { int x_distance_to_obstacle = abs(position_1.first - position_2.first); int y_distance_to_obstacle = abs(position_1.second - position_2.second); return sqrt(x_distance_to_obstacle*x_distance_to_obstacle + y_distance_to_obstacle*y_distance_to_obstacle); }</dd></dl>
/**</li>
<li>Return the next obstacle to our actual_position in the way limited by an specific area.</li>
<li>We have to look all the obstacles and:</li>
<li>- First check if it's fore the actual position. If obstacle.x is higher than actual_position_.x</li>
<li>- Second check if the obstacle is in the area. If obstacle.y is higher than area.min and lower than area.max.</li>
<li>- Third calculate nearest obstacle in the area.</li>
<li>Finally return it.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Pair of the top and bottom where we want to search the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>next_obstacle_position Next obstacle position. */ Position <a class="el" href="classWay.html#abb0ff6a97906581d1919a96d6a739abe">get_next_obstacle(const Area&amp; area) const</a> { Position next_obstacle_position = Position(-1, -1); double nearest_obstacle_distance = MAX_INT;</dd></dl>
<p>for (int i = 0; i &lt; obstacle_vector.size(); ++i) { if (obstacle_vector[i].first &lt;= actual_position_.first) { continue; } if ( (obstacle_vector[i].second &lt;= area.first) || (obstacle_vector[i].second &gt;= area.second) ) { continue; }</p>
<p class="startli">if ( nearest_obstacle_distance &gt; get_distance_between(actual_position_, obstacle_vector[i]) ) { next_obstacle_position = obstacle_vector[i]; // Return nearest obstacle in the area nearest_obstacle_distance = get_distance_between(actual_position_, obstacle_vector[i]); } }</p>
<p class="startli">return next_obstacle_position; }</p>
</li>
</ul>
<p>/**</p><ul>
<li>Return the last obstacle to our actual_position in the way limited by an specific area.</li>
<li>We have to look all the obstacles and:</li>
<li>- First check if it's behind the actual position. If obstacle.x is lower than actual_position_.x</li>
<li>- Second check if the obstacle is in the area. If obstacle.y is higher than area.min and lower than area.max</li>
<li>- Third calculate nearest obstacle in the area</li>
<li>Finally return it.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Pair of the top and bottom where we want to search the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>last_obstacle_position Last obstacle position. */ Position <a class="el" href="classWay.html#a90c9fb28926e8db8613e7e58743e0b1a">get_last_obstacle(const Area&amp; area) const</a> { Position last_obstacle_position = Position(-1, -1); double nearest_obstacle_distance = MAX_INT;</dd></dl>
<p>for (int i = 0; i &lt; obstacle_vector.size(); ++i) { if (obstacle_vector[i].first &gt;= actual_position_.first) { continue; } if ( (obstacle_vector[i].second &lt;= area.first) || (obstacle_vector[i].second &gt;= area.second) ) { continue; }</p>
<p class="startli">if ( nearest_obstacle_distance &gt; get_distance_between(actual_position_, obstacle_vector[i]) ) { last_obstacle_position = obstacle_vector[i]; // Return nearest obstacle in the area nearest_obstacle_distance = get_distance_between(actual_position_, obstacle_vector[i]); } }</p>
<p class="startli">return last_obstacle_position; }</p>
</li>
</ul>
<p>/**</p><ul>
<li>Reduce the current diameter if it is higuer than the distance to an obstacle at the back.</li>
<li>Because we have to pass through the obstacles.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diameter</td><td>Diameter of the fat person if we use this way.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area that we are analyzing in that way.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>correct_diameter Diameter adjusted if neccesary. */ double <a class="el" href="classWay.html#ab09d8ccb71e27fef142dabc525705a79">get_correct_diameter(const double&amp; diameter, const Area&amp; area) const</a> { double correct_diameter = diameter; Position last_obstacle_position = get_last_obstacle(area);</dd></dl>
<p>while (last_obstacle_position != Position(-1, -1)) {</p>
<p class="startli">double distance_to_obstacle = get_distance_between(actual_position_, last_obstacle_position);</p>
<p class="startli">if ( distance_to_obstacle &lt; diameter) { correct_diameter = distance_to_obstacle; }</p>
<p class="startli">last_obstacle_position = Position(-1, -1); }</p>
<p class="startli">return correct_diameter; }</p>
</li>
</ul>
<p>/**</p><ul>
<li>Method that creates a way with the actual_position, bottom and top and</li>
<li>adjusting the diameter if it's above the limits and calling <a class="el" href="classWay.html#ab09d8ccb71e27fef142dabc525705a79">get_correct_diameter()</a>.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is).</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom limit for searching the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top limit for searching the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> The created way. */ <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> create_way (const Position&amp; actual_position, const double&amp; bottom, const double&amp; top) const { double diameter = diameter_; if ( diameter &gt; top - bottom) { diameter = top - bottom; } Area area = Area(bottom, top); diameter = get_correct_diameter(diameter, area); return <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> (actual_position, diameter, area); }</dd></dl>
/**</li>
<li>Divides the actual way in two of them checking first if there are more obstacles in the line.</li>
<li>It checks first up and then down. If there are obstacles in that side, the method check_obstacle_in_line</li>
<li><p class="startli">will be the attendant. */ void divide_ways () { if (!check_obstacle_in_line(actual_position_, actual_position_.second, aisle_width)) { <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> way_1 = create_way(actual_position_, actual_position_.second, aisle_width); possible_way_set.insert(way_1); }</p>
<p class="startli">if (!check_obstacle_in_line(actual_position_, 0, actual_position_.second)) { <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> way_2 = create_way(actual_position_, 0, actual_position_.second); possible_way_set.insert(way_2); } }</p>
</li>
</ul>
<p>/**</p><ul>
<li>Check if there are more obstacles between the botom and the top of the current position.</li>
<li>- First it check the obstacle as this method is recursive for preventing an infinite loop.</li>
<li>- Second it get's the nearest obstacle that is in line, marked and in the area.</li>
<li>- If there have been obstacles we look if it's above our position or under it and call <a class="el" href="classWay.html#a6097f4b2873173c39bf9ef0ca01ab232">divide_ways_with_obstacle()</a>. This is neccesary</li>
<li>because the algorithm is recursive.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is).</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom limit for searching the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top limit for searching the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>obstacles_in_line Bool that indicates if the method found obstacles between botom and top of that line. */ bool <a class="el" href="classWay.html#a56251aabe4123e96a39117c4ec876b0d">check_obstacle_in_line(const Position&amp; actual_position, const double&amp; bottom, const double&amp; top)</a> { bool obstacles_in_line = false; Position nearest_obstacle; int nearest_obstacle_distance = MAX_INT;</dd></dl>
<p>checked_obstacles.push_back(actual_position);</p>
<p class="startli">for (int i = 0; i &lt; obstacle_vector.size(); ++i) { if ( (obstacle_vector[i] == actual_position) || (obstacle_vector[i].first != actual_position.first) ) { continue; } if (std::count (checked_obstacles.begin(), checked_obstacles.end(), obstacle_vector[i]) != 0) { continue; } if (obstacle_vector[i].second &gt; top || obstacle_vector[i].second &lt; bottom) {continue; }</p>
<p class="startli">if ( nearest_obstacle_distance &gt; get_distance_between(actual_position, obstacle_vector[i]) ) { nearest_obstacle = obstacle_vector[i]; nearest_obstacle_distance = get_distance_between(actual_position, obstacle_vector[i]); obstacles_in_line = true; } }</p>
<p class="startli">if (obstacles_in_line) { if (actual_position.second &lt;= nearest_obstacle.second) { divide_ways_with_obstacle(nearest_obstacle, nearest_obstacle.second, top); } else { divide_ways_with_obstacle(nearest_obstacle, bottom, nearest_obstacle.second); } }</p>
<p class="startli">return obstacles_in_line; }</p>
</li>
</ul>
<p>/**</p><ul>
<li>Special method to divide ways if an obstacle was found. We call <a class="el" href="classWay.html#a56251aabe4123e96a39117c4ec876b0d">check_obstacle_in_line()</a> to discover if there are new obstacles.</li>
<li>- If there are more obstacles the recursive method will keep the search for new obstacles until there are no more.</li>
<li>Once the search has finished the method how to divide the way depending if there were two areas of one. If there was only</li>
<li>one area it means that the height of the actual_positiion is between botom and top (Without touching). If it touchs it mean</li>
<li>that there is only one area.</li>
<li>- Finally we create the ways for the areas found.</li>
<li></li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is).</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom limit for searching the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top limit for searching the obstacle.</td></tr>
  </table>
  </dd>
</dl>
</li>
<li></li>
<li><dl class="section return"><dt>Returns</dt><dd>variableA Description. */ void divide_ways_with_obstacle (const Position&amp; actual_position, const double&amp; bottom, const double&amp; top) { // Si no hay mas, divido las dos Ã¡reas que quedan if (!check_obstacle_in_line(actual_position, bottom, top)) { if ((actual_position.second &lt; top) &amp;&amp; (bottom &lt; actual_position.second)) { <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> way_1 = create_way(actual_position, actual_position.second, top); <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> way_2 = create_way(actual_position, bottom, actual_position.second);</dd></dl>
possible_way_set.insert(way_1); possible_way_set.insert(way_2); } else { <a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> way_1 = create_way(actual_position, bottom, top); possible_way_set.insert(way_1); } } } };</li>
</ul>
<p>/**</p><ul>
<li></li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1dc5fd5102040f540de66e55c660efe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5fd5102040f540de66e55c660efe1">&sect;&nbsp;</a></span>Way() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Way::Way </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>actual_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor of a way with the neccesary parameters to continue looking for the best path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">diameter</td><td>Diameter of the fat person if we use this way. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area that we are analyzing in that way. There will be a way for any different area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2ae246e3c250ebefcb96ce02a69775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2ae246e3c250ebefcb96ce02a69775">&sect;&nbsp;</a></span>Way() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Way::Way </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWay.html">Way</a> &amp;&#160;</td>
          <td class="paramname"><em>way</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor where we use the '=' overload. Used by set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way</td><td><a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> we want to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a56251aabe4123e96a39117c4ec876b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56251aabe4123e96a39117c4ec876b0d">&sect;&nbsp;</a></span>check_obstacle_in_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Way::check_obstacle_in_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>actual_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if there are more obstacles between the botom and the top of the current position.</p><ul>
<li>First it check the obstacle as this method is recursive for preventing an infinite loop.</li>
<li>Second it get's the nearest obstacle that is in line, marked and in the area.</li>
<li>If there have been obstacles we look if it's above our position or under it and call <a class="el" href="classWay.html#a6097f4b2873173c39bf9ef0ca01ab232">divide_ways_with_obstacle()</a>. This is neccesary because the algorithm is recursive. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom limit for searching the obstacle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top limit for searching the obstacle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>obstacles_in_line Bool that indicates if the method found obstacles between botom and top of that line. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a91f4a970c553090110822cdee9f21b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f4a970c553090110822cdee9f21b72">&sect;&nbsp;</a></span>create_way()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWay.html">Way</a> Way::create_way </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>actual_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method that creates a way with the actual_position, bottom and top and adjusting the diameter if it's above the limits and calling <a class="el" href="classWay.html#ab09d8ccb71e27fef142dabc525705a79">get_correct_diameter()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom limit for searching the obstacle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top limit for searching the obstacle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> The created way. </dd></dl>

</div>
</div>
<a id="a74ca50339dea2e210391259ce0c87f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ca50339dea2e210391259ce0c87f99">&sect;&nbsp;</a></span>divide_ways()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Way::divide_ways </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides the actual way in two of them checking first if there are more obstacles in the line. It checks first up and then down. If there are obstacles in that side, the method check_obstacle_in_line will be the attendant. </p>

</div>
</div>
<a id="a6097f4b2873173c39bf9ef0ca01ab232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6097f4b2873173c39bf9ef0ca01ab232">&sect;&nbsp;</a></span>divide_ways_with_obstacle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Way::divide_ways_with_obstacle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>actual_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special method to divide ways if an obstacle was found. We call <a class="el" href="classWay.html#a56251aabe4123e96a39117c4ec876b0d">check_obstacle_in_line()</a> to discover if there are new obstacles.</p><ul>
<li>If there are more obstacles the recursive method will keep the search for new obstacles until there are no more. Once the search has finished the method how to divide the way depending if there were two areas of one. If there was only one area it means that the height of the actual_positiion is between botom and top (Without touching). If it touchs it mean that there is only one area.</li>
<li>Finally we create the ways for the areas found. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actual_position</td><td>Actual position of the way (the obstacle where it is). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom limit for searching the obstacle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top limit for searching the obstacle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variableA Description. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab09d8ccb71e27fef142dabc525705a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09d8ccb71e27fef142dabc525705a79">&sect;&nbsp;</a></span>get_correct_diameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Way::get_correct_diameter </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reduce the current diameter if it is higuer than the distance to an obstacle at the back. Because we have to pass through the obstacles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diameter</td><td>Diameter of the fat person if we use this way. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area that we are analyzing in that way. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>correct_diameter Diameter adjusted if neccesary. </dd></dl>

</div>
</div>
<a id="a43e2c66c0cdb5a6509551fa3f65e1770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e2c66c0cdb5a6509551fa3f65e1770">&sect;&nbsp;</a></span>get_diameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Way::get_diameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Diameter getter. </p><dl class="section return"><dt>Returns</dt><dd>diameter_ Diameter of the fat person if we use this way. </dd></dl>

</div>
</div>
<a id="aa2789fa1b2e365d8c896c66fb076d1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2789fa1b2e365d8c896c66fb076d1de">&sect;&nbsp;</a></span>get_distance_between()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Way::get_distance_between </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>position_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>position_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance between two position of our way using the euclidian algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position_1</td><td>First position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position_2</td><td>Second position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Euclidian distance. </dd></dl>

</div>
</div>
<a id="a90c9fb28926e8db8613e7e58743e0b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c9fb28926e8db8613e7e58743e0b1a">&sect;&nbsp;</a></span>get_last_obstacle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> Way::get_last_obstacle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the last obstacle to our actual_position in the way limited by an specific area. We have to look all the obstacles and:</p><ul>
<li>First check if it's behind the actual position. If obstacle.x is lower than actual_position_.x</li>
<li>Second check if the obstacle is in the area. If obstacle.y is higher than area.min and lower than area.max</li>
<li>Third calculate nearest obstacle in the area Finally return it. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Pair of the top and bottom where we want to search the obstacle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last_obstacle_position Last obstacle position. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="abb0ff6a97906581d1919a96d6a739abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0ff6a97906581d1919a96d6a739abe">&sect;&nbsp;</a></span>get_next_obstacle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> Way::get_next_obstacle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the next obstacle to our actual_position in the way limited by an specific area. We have to look all the obstacles and:</p><ul>
<li>First check if it's fore the actual position. If obstacle.x is higher than actual_position_.x</li>
<li>Second check if the obstacle is in the area. If obstacle.y is higher than area.min and lower than area.max.</li>
<li>Third calculate nearest obstacle in the area. Finally return it. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Pair of the top and bottom where we want to search the obstacle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next_obstacle_position Next obstacle position. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae8b6bd43a694231699729c4df69c0538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b6bd43a694231699729c4df69c0538">&sect;&nbsp;</a></span>get_next_ways()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Way::get_next_ways </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method used to know in which ways we can divide our problems.</p><ul>
<li>First we look for the next obstacle in our way (attending to the area).</li>
<li>If there are no more obstacles we insert this one in the finished_way_set.</li>
<li>If there are more obstacles we diviide our way in <a class="el" href="classWay.html#a74ca50339dea2e210391259ce0c87f99">divide_ways()</a>. </li>
</ul>

</div>
</div>
<a id="afd5aa157413b5ab19621cbe84f6d02f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5aa157413b5ab19621cbe84f6d02f5">&sect;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWay.html">Way</a>&amp; Way::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWay.html">Way</a> &amp;&#160;</td>
          <td class="paramname"><em>way</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the operator '='. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way</td><td><a class="el" href="classWay.html" title="Represent a way in the test. Each time that we see an obstacle, instead of going to the bigger side...">Way</a> we want to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3e83ee1ea2a22d2c44c613adc5cc6760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e83ee1ea2a22d2c44c613adc5cc6760">&sect;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWay.html">Way</a> &amp;&#160;</td>
          <td class="paramname"><em>way_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWay.html">Way</a> &amp;&#160;</td>
          <td class="paramname"><em>way_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to compare two ways. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">way_1</td><td>First way. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">way_2</td><td>Second way. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a78a964b350c8b64c1fdc64aebd9ba121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a964b350c8b64c1fdc64aebd9ba121">&sect;&nbsp;</a></span>actual_position_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a> Way::actual_position_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actual position of the way (the obstacle where it is). </p>

</div>
</div>
<a id="ad255829300df475c7e95213b9f7da31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad255829300df475c7e95213b9f7da31f">&sect;&nbsp;</a></span>area_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="main_8cpp.html#a56b2acabc8b26c50ae1629b314250cec">Area</a> Way::area_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Area that we are analyzing in that way. There will be a way for any different area. </p>

</div>
</div>
<a id="a6304bad84a34c3b19368a2cdb37db2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304bad84a34c3b19368a2cdb37db2d3">&sect;&nbsp;</a></span>checked_obstacles</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="main_8cpp.html#afd8254537355e84998572e36d9b22135">Position</a>&gt; Way::checked_obstacles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obstacles that we have seen (used in </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classWay.html#a56251aabe4123e96a39117c4ec876b0d">check_obstacle_in_line()</a>). </dd></dl>

</div>
</div>
<a id="a39b2f2c249bc1d99da8805ab03284469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b2f2c249bc1d99da8805ab03284469">&sect;&nbsp;</a></span>diameter_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Way::diameter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Diameter of the fat person if we use this way. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="main_8cpp.html">main.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classWay.html">Way</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
